
## 爬虫
网页编码解析
User-Agent 设置
代理IP设置

## jwt
头部-载荷-签名
如何实现自动用户长期免登录
作为access_token 返回给登录用户，并将 uid:jwt 组合作为 key 存入 redis，设置过期时间为七天
当用户携带 access_token 访问接口时，判断是否有效且在 redis 中存在，若存在则延长过期时间 否则提示权限失效，重新登陆
用户登出和修改密码时删除 redis 中的旧 access_token，并按规则生成新的存入、返回

## 接口的幂等性方案
查询 天然幂等  
删除 也是幂等的，但返回结果可能不一样，数据不存在返回0，数据多条返回多个  
新增 给表添加唯一索引  
token机制：在数据提交前需向服务申请token，token在生成时同时存入redis，数据提交后删除redis中的token，若删除成功则继续，否则说明不是第一次请求了  
状态机幂等：在更新数据时添加状态条件，例如修改上架货物为下架时，更新条件加上上架状态  
对第三方接口保持幂等：如接入商户提交付款请求时需添加source+seq，即来源+序列号，并在数据表里添加为组合唯一索引  


## mysql
### 三大范式  
  

### 存储引擎 
MyISAM，Innodb 区别  
### 索引 
一种能协助快速查询更新数据库表的数据结构  

什么时候会用到索引？ where、order by、 join on 的字段  
索引类型：主键索引、唯一索引、普通索引、全文索引  
索引的数据结构：BTree、hash  
索引设计原则：
> where 子句中的列，join字句中的列 频繁用到的适合索引   
> 最左前缀匹配原则，组合索引会一直向右匹配直到遇到范围查询就停止匹配，如 a=1 and b=2   and c > 3 and d=4，如果索引顺序为(a, b, c, d)则 d 不会用到索引，如果为(a, b, d,   c)则都可用到，且 a, b, d 三者之间顺序可任意调整  
> 更新频繁的字段不适合创建索引  
> 不能有效区分数据的列不适合做索引，如性别(男/女/未知，就三种，区分度太低)  
> 查询很少涉及的列，重复值比较多的列不要建立索引  
> 尽量扩展索引，不新建索引，如表中已有 a 索引，现在要加 (a, b)索引，修改原来的索引即可  
> 定义有外键的数据列一定要建立索引  
> 定义为 text、image 和 bit 的数据类型的列不建立索引  
> 不要过度索引，因为需要额外的磁盘空间  

索引创建的注意点  
> 非空字段，指定列为NOT NULL，用 0、特殊值或空字符串代替 NULL  
> 取值离散大的字段的列放在联合索引的前面  
> 索引字段越小越好  

**事务**  
四大特性：ACID  
原子性、一致性、隔离性、持久性  

锁：数据库有并发事务时可能会产生数据的不一致，需要锁机制来保证访问次序  
锁可根据粒度分为：行级锁、页级锁、表级锁  
他们的开销从大到小，并发能力也是从大到小，但前两者可能死锁  
MyISAM采用表级锁，InnoDB支持行级锁和表级锁  
InnoDB基于索引完成行锁 select * from tableA where id = 1 for update  
锁可根据类别分为：共享锁和排他锁  
共享锁又叫读锁，在用户对数据读取时加上，可同时加多个  
排他锁又叫写锁，在用户进行写入数据时加上，和其他的排他锁、共享锁都相斥  

死锁：指多个事务在统一资源上相互占用，并请求锁定对方的资源，导致恶性循环的现象  
解决方式
1. 一次锁定所需要的资源，减少死锁概率
2. 升级为表级锁  
乐观锁：假定并发事务不会发生冲突，只在提交操作时检查数据完整性，修改时把事务锁起来，通过版本号 version 的方式来实现  
悲观锁：假定并发事务发生冲突，在查询玩数据是就把事务锁起来，直到提交事务，通过数据库锁机制来实现  

读取多，写入少的场景适用乐观锁，读取少，写入多场景适合悲观锁  

**视图**  
视图：由基本表产生的虚拟表，列可来自不同表  
目的是为了提高复杂SQL预计的复用性和表操作的安全性  
视图的建立和删除不影响基本表  
视图内容的更新(增删改)直接影响基本表  

**SQL语句**  
SQL语句主要分四类  
数据定义语言DDL: create drop alter  
数据查询语言DQL: select  
数据操纵语言DML: insert update delete  
数据控制功能DCL: grant revoke commit rollback  

子查询：一条SQL语句的查询结果作为另一条查询语句的条件或查询结果，内部的SQL查询称为子查询  

drop/delete/truncate区别  
delete可回滚，truncate和drop不可回滚  
delete 删除速度慢，truncate 和 drop 删除速度快  
delete 删除部分数据，truncate 删除全部数据，drop删除全部数据、表结构、索引和权限
UNION 和 UNION ALL  
UNION ALL 不会合并重复的记录行，UNION 效率高于 UNION ALL  

超大分页的解决方式  
将 select * from table where age > 20 limit 1000000,10 改为  
select * from table where id in (select id from table where age > 20 limit 1000000,10)  
可以减少 load 的数据，加快查询效率  

开启慢查询日志  
配置项： slow_query_log  
语句： set GLOBAL slow_query_log = on  
设置临界时间 long_query_time  
语句： set long_query_time = 0.5  

字段为什么要求定义为 not null  
null 会占用更多字节，会在程序中造成很多与预期不符的情况  
在 where 子句中对字段进行null值判断时，会导致引擎放弃使用索引而进行全表扫描  

密码散列和用户身份证号等固定长度的字符串应该使用 char 而不是 varchar 节省空间且提高检索效率  
count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)  


关联查询优化：
> ON/USING 子句中使用索引字段；
> 确保 GROUP BY 和 ORDER BY 只有一个表的列，这样才可能使用索引


可能导致引擎放弃索引而使用全表扫描的操作：
> 在where子句中使用 != 或 <> 或 or  
> in 和 not in 也要慎用  
> like '%xxxx'也是同理  
> 对字段进行函数操作，如 select id from t where substring(name, 1, 3) = 'abc'  


大表优化
1. 限定查询语句的数据范围，如用户查询历史订单时控制在一个月范围内
2. 读写分离，主库负责写，从库负责读
3. 使用MySQL缓存
4. 分库分表

分表有两种方式： 垂直分区和水平分区
1. 垂直分区：根据数据库里面数据表的相关性进行拆分。  
   垂直拆分就是数据表列的拆分  
   例如用户表中既有用户的登录信息又有用户的基本信息，可以拆分成两个单独的表  
   优点：使行数据变小，查询时减少IO次数，减少表结构易于维护  
   缺点：主键会冗余，并会引起 join 操作(可在应用层解决)，会让事务变得更复杂  
   适用场景：数据表列太大，有些列常用，有些列不常用  
2. 水平分区：指数据表行的拆分，每片数据分散到不同的表或库中，达到分布式的目的  
    需注意：分表仅仅解决了单一表数据过大的问题，表的数据还是在同一台机器上，对提升并发能力并没有什么意义，水平拆分最好分库  
    优点：能支持非常大的数据量存储，应用端改造也少，降低查询需要读的数据和索引页数  
    缺点：分片事务难以解决，跨界点join性能较差，逻辑复杂  
    
MySQL复制原理及流程
主从复制：将主数据库中的DDL和DML操作通过二进制日志传输到从数据库上，然后将这些日志重新执行，使得从数据库数据与主数据库保持一致
作用：
    1. 主数据库出现问题可切换到从数据库
    2. 可进行数据库层面的读写分离
    3. 可在从数据库上进行日常备份
解决了哪些问题：
    1. 数据分布。随意开始或停止复制，并在不同地理位置分布数据备份
    2. 负载均衡。降低单个服务器的压力
    3. 高可用和故障切换。帮助应用程序避免单点失败
    4. 升级测试。可用更高版本的MySQL作为从库
工作原理
    1. 在主库把数据更改记录到二进制日志
    2. 从库吧主库日志复制到自己的中继日志
    3. 从库读取中继日志的事件，将其存放到从库数据中
三个线程：主库的binlog线程，从库的io线程，从库的sql执行线程

MySQL读写分离解决方案
读写分离依赖于主从复制，主从复制是为读写分离服务的


## redis
一个C语言开发的单线程的基于内存的高性能 key-value 非关系型数据库
用途：数据库、缓存、消息中间件
常用数据类型：string、list、hash、set、sorted set
并发问题：单进程单线程模式，采用队列模式将并发访问变为串行访问，redis没有锁的概念，redis对于多个客户端连接不存在竞争
支持的语言： java、C、C#、C++、php、Node.js、Go等
持久化方案：RDB和AOF
1. RDB文件紧凑，体积小，适合全量复制，恢复速度比AOF快，对性能影响小，
   缺点：无法实时持久化，兼容性差(老版本不兼容)，因此AOF是目前主流
2. AOF 支持秒级持久化，兼容性好，缺点：文件大，恢复速度慢，对性能影响大
主从复制
分片模型
Redis哨兵
常用指令：
    启动服务 ./redis-server
    启动客户端 redis-cli
常见问题：缓存击穿、缓存雪崩、缓存并发、与数据库一致性
Redis分布式：读写分离，master插入，slave检索，缺陷在于主从都需保存完整数据，集群的扩展受限于单个节点的存储能力，对于频繁写入类型的应用，读写分离架构并不合适
过期时间设置
    expire key seconds: 设置 key 在 n 秒后过期
    pexpire key milliseconds: 设置 key 在 n 毫秒后过期
    expireat key timstamp: 设置 key 在某个时间戳(秒)后过期
    pexpireat key millisecondsTimestamp: 设置 key 在某个时间戳(毫秒)后过期

常见性能问题：
    master不做任何持久化工作；
    为了主从复制的速度和连接的稳定，master和slave最好在同一具局域网；
    使用 scan 系列命令完成数据迭代
    
## RabbitMQ
## Elasticsearch

## docker/k8s
镜像：类似虚拟机镜像，提供运行环境
容器：镜像的实例，可创建停止删除，容器间是互相隔离的
仓库：镜像仓库，类似代码仓库，

## linux/shell

## Node.js 
垃圾回收机制
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境
V8 就是Node.js中使用的虚拟机
V8 之于 Node.js 相当于 JVM 之于 Java
