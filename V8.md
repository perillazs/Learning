# V8 学习
## 概述
### What is V8
V8 是 JavaScript 虚拟机中的一种，用来将编程语言转为机器语言
![引擎](https://static001.geekbang.org/resource/image/8a/a1/8a40fd003baa9be179fe2e55a1be5fa1.jpg)

### How to Learn V8
首先要了解 JavaScript 设计思想
- C语法
- Java类型系统、垃圾回收
- Scheme函数作为一等公民
- Self基于原型的继承机制

![JavaScript思想](https://static001.geekbang.org/resource/image/f8/7a/f8fb9e3570b88152f9ab7b6b8d385c7a.jpg)

V8 执行 JavaScript 代码的流程，即编译流水线
![V8编译流水线](https://static001.geekbang.org/resource/image/8a/54/8a34ae8c1a7a0f87e19b1384a025e354.jpg)

隐藏类，是将 JavaScript 中动态类型转为静态类型的一种技术，可消除动态类型的语言执行速度过慢的问题，了解该特性可写出更加高效的 JavaScript 代码  

惰性解析，目的是为了加速代码的启动速度  

除编译流水线外，还有两个非常重要的特性：**事件循环系统**和**垃圾回收机制**

V8的事件循环系统会调度排队任务，保证 JavaScript 代码被V8有序的执行，事件循环系统就是V8的内脏。  

JavaScript 是一种自动垃圾回收的语言。  
执行垃圾回收时，会占用主线程的资源。  
需注意，若编写的程序频繁触发垃圾回收则会阻塞主线程。
![V8知识图谱](https://static001.geekbang.org/resource/image/90/43/90228d5cc0afbaaa4cca3fbdb1349243.jpg)

## V8是如何执行一段JavaScript代码的

高级代码为什么需要先编译再执行？  
CPU只能执行二进制的指令。  
对程序员来说二进制代码难以阅读和记忆，于是将二进制指令集转换为人类可以识别和记忆的符号，这就是汇编指令级  
![汇编指令级](https://static001.geekbang.org/resource/image/6b/1f/6bb6d19ec37ea1a7d2cab2a25ea62b1f.jpg)

但是编写会变大吗还需要了解处理器架构相关的硬件知识，比如使用寄存器、内存、操作CPU等。  
我们需要一种屏蔽了计算机架构细节的语言，能适应多种不同CPU架构的语言，能专心处理业务逻辑的语言，如C、C++、Java、C#等这些**高级语言**

与汇编语言相同，处理器不能直接识别由高级语言所编写的代码，通常有两种方式来执行这些代码，**解释执行**和**编译执行**

解释执行流程  
先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果  
![解释执行流程](https://static001.geekbang.org/resource/image/33/5e/330ad69589d898f6609dfc083bfbe95e.jpg)

编译执行流程  
现将源代码转为中间代码，然后编译器将中间代码编译成机器代码。通常编译成的机器代码是以二级制文件形式存储的。  
![编译执行流程](https://static001.geekbang.org/resource/image/1f/d3/1f933e42e81dacc8f4f2d86e01a914d3.jpg)

不同的高级语言执行方式也有差异，如C语言编写的代码愮先编译成二进制代码文件，再直接执行二进制代码，而向Java、JavaScript则需要不同的虚拟机，模拟计算机编译执行流程。  

V8混合编译执行和解释执行两种手段，我们把这种混合使用编译器和解释器的技术成为JIT(Just In Time)技术  
解释执行启动速度快，但执行时速度慢  
编译执行启动速度慢，到那时执行速度快  
![V8执行JavaScript流程](https://static001.geekbang.org/resource/image/8a/54/8a34ae8c1a7a0f87e19b1384a025e354.jpg)

V8源代码的结构化之后就生成了抽象语法树AST，AST是便于V8理解的结构  
在生成AST的同时，V8还会生成相关的作用域，作用域中存放相关变量  

V8执行一段JavaScript代码所经历的主要流程
- 初始化基础环境
- 解析源码生成AST和作用域
- 根据AST和作用域生成字节码
- 解释执行字节码
- 监听热点代码
- 优化热点代码为二进制的机器代码
- 反优化生成的二进制机器代码

JavaScript是一门动态语言，在运行过程中，某些被优化的结构可能会被V8动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。  

## 函数即对象
JavaScript中的函数时一种特殊的对象，称为**一等公民(First Class Function)**  
基于该设计，是的JavaScript容易实现一些特性，如**闭包**、**函数式编程**  

### 什么是JavaScript中的对象
JavaScript是一门**基于对象(Object-Based)**的语言，却不是一门**面向对象的语言(ObjectOriented Programming Language)**，因为面向对象语言天生支持**封装、继承、多态**，但JavaScript并没有直接提供多态的支持  
JavaScript中实现继承的方式非常简单，只是在对象中添加了一个成为原型的属性，把继承的对象通过原型链接起来，就是心啊了继承，这种继承方式就称为基于原型链的继承。  
JavaScript中的对象也很简单，每个对象就是由一组组属性和值构成的集合  
对象的属性由三种类型：  
1. **原始类型**  
  原始类型数据是指值本身无法被改变的类型，有如下七种
    - Number
    - String
    - Bigint
    - Boolean
    - Null
    - Undefined
    - Symbol

2. **对象类型**  
  对象的属性值可以是另外一个对象
3. **函数类型**  
  对象的属性值若是函数，那么我们把这个属性称为方法。

### 函数的本质
在JavaScript中，函数是一种特殊的对象，它和普通对象一样拥有属性和值，与一般对象不同的是函数对象可以被调用  
在V8内部，会为函数对象添加两个隐藏属性，分别是 name 和 code  
name属性的值就是函数名称，如果某个函数没有设置函数名，那么它默认的name属性值就是 anonymous 表示该函数对象没有设置名称  
code属性值就是函数代码，以字符串形式存储在内存中  
当执行到一个函数调用语句时，V8便会从函数对象中取出code属性值，即函数代码，然后再解释执行这段代码  

### 函数是一等公民
在JavaScript中，函数可以赋值给一个变量，也可以作为函数参数，还可以函数的返回值  
**如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民**  

在执行JavaScript函数过程中，为了实现变量的查找，V8会为其维护一个作用域链，如果函数中使用了某个变量，但是函数内部没有定义该变量，那么函数就会沿着作用域链去外部的作用域中查找该变量。
![查找变量](https://static001.geekbang.org/resource/image/8b/fd/8bb90b190362e3a00e5a260bad6829fd.jpg)

当函数内部引用了外部的变量时，使用这个函数进行**赋值**、**传参**或**作为返回值**，需要保证这些被引用的外部变量是存在的。  
``` JavaScript
function foo() {
  var number = 1
  function bar() {
    number++
    console.log(number)
  }
  return bar
}
var mybar = foo()
mybar()
```
从上端代码可见，返回函数bar给外部，那么即使foo函数之行结束了，其内部定义的number变量也不能被销毁，因为bar函数依然引用了该变量。  
我们把这种将外部变量和函数绑定起来的技术称为闭包。  

函数是一等公民的特性
- 函数作为一个对象，有自己的属性和值，所以函数关联了基础的属性和值  
- 函数之所以成为特殊的对象，这个特殊的地方是函数可以被调用，所以一个函数被调用时，还需要关联相关的执行上下文  


## 快属性和慢属性
V8在实现对象存储时，没有完全采用字典的存储方式，主要出于性能的考量  
因为字典是非线性的数据结构，查询效率低于线性的数据结构。  
V8为了提升存储和查找效率，采用了复杂的存储策略  
![线性结构和非线性结构](https://static001.geekbang.org/resource/image/c9/ef/c970cdc7b89bfe0a12e560fe94fcdfef.jpg)

### 常规属性(properties)和排序属性(element)
在JavaScript设置数字属性和字符串属性后打印该对象  
- 数字属性被最先打印出来，且按照数字大小顺序打印  
- 字符串属性依然是按照设置的顺序打印的，比如按照B、A、C顺序设置，那么打印出来依然是这个顺序  

**ECMAScript规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列**  
这里我们把对象中的数字属性称为**排序属性**，在V8中被称为**elements**，字符串属性被称为**常规属性**，在V8中被称为**properties**

在V8内部是用来两个**线性数据结构**来分别保存排序属性和常规属性来提升存储和访问性能
![V8内部对象构造](https://static001.geekbang.org/resource/image/af/75/af2654db3d3a2e0b9a9eaa25e862cc75.jpg)  

### 快属性和慢属性
将不同属性分别保存到elements属性和properties属性中简化了程序复杂度，但是在查找元素时却多了一步，会影响到元素的查找效率  
基于此，V8采取了一个权衡策略来加快查找属性的效率，即将部分常规属性直接存储到对象本身，称之为**对象内属性(in-object properties)**
![对象内属性](https://static001.geekbang.org/resource/image/f1/3e/f12b4c6f6e631ce51d5b4f288dbfb13e.jpg)

对象内属性数量是固定的，默认是10个，如果属性数量超过了对象分配空间，则将被保存在常规属性存储中。  
通常将保存在线性数据结构中的的属性称之为快属性。因为线性数据结构只需索引即可访问到属性。线性结构访问速度快，但是添加或删除大量属性时，执行效率会非常低，因为会产生大量时间和内存开销  
因此如果一个对象属性过多，V8会采取慢属性存储策略。慢属性对象内部有独立的非线性数据结构(词典)作为属性存储器。  
![慢属性如何存储](https://static001.geekbang.org/resource/image/e8/17/e8ce990dce53295a414ce79e38149917.jpg)  

除了elements和properties属性，V8还为每个对象实现了map属性和__proto__属性，其中map是隐藏类，__proto__属性就是原型  


## 函数表达式
函数声明和函数表达式  
函数声明可以在声明函数代码前面调用  
函数表达式只能在定义函数代码之后调用  
在编译阶段，把所有变量提升到作用域的过程称为变量提升  

![表达式和语句](https://static001.geekbang.org/resource/image/24/43/244971073e6e41d10cefbb1de13bb343.jpg)

V8执行 var x = 5 时，会认为这是两段代码，一段是定义变量的语句，一段是赋值的表达式  
``` JavaScript
var x = undefined
x = 5
```
这两行代码是在不同阶段完成的，`var x` 是在编译阶段完成的，也可以说是变量提升阶段完成的  
而x = 5是表达式，所有表达式都在执行阶段完成的  

**表达式不会在编译阶段执行**  

函数声明是一个语句，而不是表达式  
函数声明也会被V8执行变量提升操作  
函数也是一个对象，在编译阶段V8就会将整个函数对象提升到作用域中，而不是给函数名称赋值一个undefined  

函数表达式与函数声明的区别
- 函数表达式是在表达式语句中使用 function的，最典型的表达式是`a = b`这种形式，因为函数也是一个对象，我们把`a = function() {}` 这种方式称为函数表达式  
- 在函数表达式中，可以省略函数名称来创建匿名函数(anonymous functions)  
- 一个函数表达可以被用作一个即时调用的函数表达式 IIFE (Immediately Invoked Function Expression)  

### 立即调用的函数表达式(IIFE)
编译阶段，V8并不会处理函数表达式，JavaScript中的立即调用函数表达式正是使用了这个特性  
JavaScript中有一个圆括号运算符，里面可以放一个表达式  
``` JavaScript
(a=3)
```
括号里是表达式，整个语句也是一个表达式，最终输出3
因为小括号之间存放的必须是表达式，所以如果在小括号内定义一个函数，那V8就会把这个函数看成是函数表达式，执行时它会返回一个函数对象，此时直接在表达式后面加上调用的括号，这就称为立即调用函数表达式(IIFE)  
``` JavaScript
(function() {
// statement
})()
// 另一种写法
(function() {

}())
```
V8在编译阶段不会为该表达式创建对象，这样不会污染环境，函数和函数内部变量不会被其他部分代码访问到  
因为函数立即表达式是立即执行的，将一个函数立即表达式赋给一个变量时，不是存储IIFE本身，而是存储IIFE执行后返回的结果
``` JavaScript
var a = (function(){
  return 1
})()
```

## 原型链
简单的理解，继承就是一个对象可以访问另一个对象中的属性和方法  
最典型的两种实现继承的方式是**基于类的设计**和**基于原型继承的设计**  

## 作用域链

## 类型转换

# V8编译流水线
## 运行时环境

## 机器代码
## 堆和栈
## 延迟解析
## 字节码
## 隐藏类
# 事件循环和垃圾回收
## 消息队列
从内部了解回调函数可以梳理清很多问题
- 有助于我们理解浏览器中的Web API工作原理
- 理解宏任务和微任务的区别
- 是理解异步编程模型async/await的基础  

### 什么是回调函数
回调函数区别于普通函数在于它的调用方式，只有当某个函数被作为参数，传递给另一个函数，或者传递给宿主环境，然后该函数在函数内部或者宿主环境中被调用，才被称为回调函数  

回调函数有两种形式，同步回调和异步回调  
同步回调函数是在执行函数内部被执行的，异步回调函数是在执行函数外部被执行的  
和同步回调函数不同的是，异步回调不是在执行函数内部被执行的，而是在其他的位置和时间点被执行的，比如 setTimeout ，回调函数在等待一段时间后才会被V8调用，并不在setTimeout函数内部执行，因此是一个异步回调  

想要了解异步回调函数的执行时机和位置，需要了解V8在运行时的线程模型，这涉及到了消息队列，事件循环等概念，这些概念和V8的县城架构模型相关。  


### UI线程的宏观架构
UI线程提供一个消息队列，并将待执行的事件添加到消息队列中，然后UI线程不断循环地从消息队列中取出事件，执行事件  

异步回调也有两种不同的类型，代表是 setTimeout 和 XMLHttpRequest
setTimeout 的执行流程：在函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数  
XMLHttpRequest 稍微复杂点，因为下载过程需要单独放到一个独立的线程中去执行，所以执行XMLHttpRequest.send 的时候，宿主回将实际请求转发给网络进程，然后 send 函数推出，主线程继续执行下面的任务。网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加到消息队列中，然后主线程从消息队列中去除回调事件并执行回调函数  





## 微任务
**宏任务**，指消息队列中的等待被主线程执行的事件。每个宏任务在执行时，V8都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，当宏任务执行结束时，整个栈又会被清空，主线程继续执行下一个宏任务  
**微任务**，可把微任务看成一个需要异步执行的函数，执行时机在主函数执行结束后，当前宏任务结束之前  

微任务可以在实时性和效率之间做一个有效的权衡  
另外，使用微任务可以改变现在的异步编程模型，是我们可以用同步形式的代码来编写异步调用  

![微任务知识栈](https://static001.geekbang.org/resource/image/1b/46/1b0ea2180dd2406b988b424cc2933746.jpg?wh=2284*864)  

### 主线程、调用栈、消息队列
调用栈是一种数据结构，用来管理在主线程上执行的函数的调用关系。
``` JavaScript
function bar(){}
function foo(fun) { fun() }
foo(bar)
```
当 V8 准备执行这段代码时，会先将全局执行上下文压入到调用栈中  
然后 V8开始在主线程上执行 foo 函数，首先创建 foo 函数的执行上下文，然后将其压入栈中  
然后 foo 函数又调用了 bar 函数，当 V8 执行 bar 函数时，同样要创建 bar 函数的上下文并压入栈中  
等 bar 函数执行结束，V8 就从栈中弹出 bar 函数的上下文  
最后 foo 函数执行结束，V8 会将 foo 函数的执行上下文从栈中弹出。

以上就是调用栈管理主线程上函数调用的方式，这种方式会带来一个问题，就是栈溢出

当函数嵌套层数过深时，过多的执行上下文堆积在栈中回导致栈溢出，如下图所示
![栈溢出](https://static001.geekbang.org/resource/image/81/25/814b88dc157ef6f43403f46e271ae625.jpg?wh=2284*1285)  

可以使用 setTimeout来解决栈溢出的问题，setTimeout 的本质时将同步函数调用改成异步函数调用  
这里的异步调用时将 foo 封装成事件，将其添加进消息队列中，然后主线程再按照一定规则循环从消息队列中读取下一个任务  
``` JavaScript
function foo() {
  setTimeout(foo, 0)
}
foo()
```
因为 foo 函数并不是在当前的夫函数内部被执行的，而是封装成了宏任务，并丢尽了消息队列中，然后等待主线程从消息队列中取出该任务，再执行该回调函数foo，这样就解决了栈溢出的问题  
其实用 setImmediate() 也可以

**微任务解决了宏任务执行时机不可控的问题**  
上面解决栈溢出的问题时，宏任务需要被放到消息队列中，如果某些宏任务的执行时间过久，回影响到消息队列后面的宏任务的执行，该影响不可控，不能确定前面的宏任务要多久才能完成。  
于是 JavaScript 又引入了微任务，微任务会在当前的任务快要结束时执行，利用微任务可以精准的控制回调函数的执行时机  
V8 会为每个宏任务维护一个微任务队列。
- 首先，如果当前任务中产生了一个微任务，出发的微任务不会在当前函数中执行，所以执行微任务时不会导致栈的无限扩张  
- 其次，和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也意味着当前微任务执行结束之前，消息队列中其他任务时不可能被执行的  

因此，**在函数内部触发的微任务，一定比函数内部触发的宏任务要优先执行**  
``` JavaScript

function bar(){
  console.log('bar')
  Promise.resolve().then(
    (str) =>console.log('micro-bar')
  ) 
  setTimeout((str) =>console.log('macro-bar'),0)
}


function foo() {
  console.log('foo')
  Promise.resolve().then(
    (str) =>console.log('micro-foo')
  ) 
  setTimeout((str) =>console.log('macro-foo'),0)
  
  bar()
}
foo()
console.log('global')
Promise.resolve().then(
  (str) =>console.log('micro-global')
) 
setTimeout((str) =>console.log('macro-global'),0)
```
输出结果为
```
foo
bar
global
micro-foo
micro-bar
micro-global
macro-foo
macro-bar
macro-global
```
![流程图](https://static001.geekbang.org/resource/image/34/db/34fb1a481b60708360b48ba04821f6db.jpg?wh=2284*1143)

在为任务队列中的所有微任务都执行完成后，当前宏任务才算执行结束，接下来主线程继续重复执行，取出任务、执行任务的过程

微任务是在当前任务快要执行结束之前执行，宏任务是消息队列中的任务，主线程完成一个任务之后，会接着从消息队列中取出下一个宏任务并执行  

### 可以在微任务中循环触发新的微任务
微任务可以像宏任务一样解决栈溢出的问题  
```
function foo() {
  return Promise.resolve().then(foo)
}
foo()
```
当执行 foo 函数时，由于 foo 函数中调用了 Promise.resolve() 这会触发一个微任务，此时 V8 会将该微任务添加进为任务队列中，退出当前 foo 函数的执行  
然后 V8 在推出当前宏任务之前，会检查微任务队列，若有则先执行微任务。这个循环会一直持续，当前宏任务无法退出，意味着消息队列中其他宏任务无法执行。  
不过由于 V8 每次执行微任务都会推出当前 foo 函数的调用栈，因此这段代码不会造成栈溢出  



## async/await
JavaScript是基于单线程设计的，因此会出现大量回调场景。  
当 JavaScript 中有大量异步操作时，会降低代码可读性，比如回调地狱  
JavaScript 社区推出一些列方案，从 `Promise 加 then` 到 `generator 加 co`，最终使用 `async/await` 方案解决了回调地狱造成的问题  

协程是一种比线程更加轻量级的存在。  
如果从 A 协程启动 B 协程，我们就把 A 协程成为 B 协程的父协程  
如同一个进程可拥有多个线程，一个线程可以拥有多个协程。  
在同一时刻，线程只能执行其中某一个协程。  
协程不被操作系统内核管理，完全由程序所控制，性能得到提升，不会像线程切换那样消耗资源  

在 JavaScript 中，生成器就是协程的一种实现方式  

通常我们把执行生成器的代码封装成一个函数，这个函数驱动函数往下执行，我们把这个执行生成器代码的函数成为执行器（可参考著名的 co 框架）

**async/await 异步编程的终极方案**  
生成器需要使用额外的co函数来驱动生成器函数的执行，非常不友好  
基于此 ES7 引入了 async/await 改进了生成器的缺点，提供了**不阻塞主线程的情况下使用同步代码实现异步访问资源的能力**  

根据MDN定义，**async是一个通过异步执行并隐式返回Promise作为结果的函数**  
如果在 async 函数里使用了 await，此时 async 函数就会暂停执行，并等待合适的时机来恢复执行，因此说 async 是一个**异步执行**的函数  

await 可以等待两种类型的表达式  
- 任何普通表达式
- 可以是一个 Promise 对象的表达式

如果 await 等待的是一个 Promise 对象，会暂停执行生成器函数，直到 Promise 对象的状态变成 resolve 才会恢复执行，将 resolve的值作为 await 表达式的运算结果  

和生成器函数一样，使用了 async 声明的函数在执行时，也是一个单独的协程，可用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，可以用 resolve 来恢复该协程  




## 垃圾回收器
JavaScript 是一门自动垃圾回收的语言，即我们不需要手动回收垃圾数据，一切都交给 V8 的垃圾回收器完成  
V8 为了更高效的回收垃圾，引入了两个垃圾回收器，针对不同场景  

**垃圾数据是如何产生的**  
无论什么语言，数据都会被存放到栈和堆中，通常方式是在内存中创建一块空间来使用，并在不需要的时候回收这块空间  

``` JavaScript
window.test = new Object()
window.test.a = new Unit16Array(100)
```
![堆栈情况](https://static001.geekbang.org/resource/image/42/b1/42b70203c6da641831d778ce08a7a5b1.jpg?wh=2284*804)

此时将另一个对象赋给了 a 属性
``` JavaScript
window.test.a = new Object()
```
此时内存布局如下
![内存布局](https://static001.geekbang.org/resource/image/9c/dc/9c44e8bb2a75a8da72877c8a192967dc.jpg?wh=2284*791)

这时堆中的数组对象就成了垃圾数据

**垃圾回收算法**  
垃圾回收步骤如下  
第一步，通过GC Root 标记空间中**活动对象**和**非活动对象**  
  目前 V8 采用**可访问性(reachability)算法**来判断堆中的对象是否是活动对象  
  - 通过 GC Root 遍历到的对象，是**可访问的(reachable)**  
  - 通过 GC Root 没有遍历到的对象，则是**不可访问的(unreachable)**  

第二步，回收非活动对象所占据的内存。就是在所有的标记完成之后，统一清理内存中所有标记为可回收的对象  
第三步，做内存整理。一般在频繁回收对象后，内存中会存在大量不连续空间，这些不连续的内存空间成为**内存碎片**，在需要分配较大的连续内存时，大量的内存碎片会导致内存不足，因此需要整理这些内存碎片。  

目前 V8 采用两个垃圾回收器，**主垃圾回收器-Major GC** 和 **副垃圾回收器-Minor GC(Scavenger)**
之所以使用两个垃圾回收器，是因为受到**代际假说(The Generational Hypothesis)**影响  

代际假说时垃圾回收领域一个重要术语，有两个特点：
- 第一个是大部分对象都是“朝生夕死”的，即大部分对象在内存中存活时间很短，如函数内部生命的变量，或块级作用域中的变量，当函数或代码块执行结束时，作用域中定义的变量就会被销毁，因此这类对象一经分配内存，很快就变得不可访问。
- 第二个是不死的对象会活得更久，如全局的 window、DOM、Web API等对象

这两个特点也适用于大多数编程语言，如Java、Python等

在 V8 中，会把堆分成**新生代**和**老生代**两个区域  
**新生代中存放的时生存时间短的对象，老生代中存放生存时间久的对象**  
新生代通常只支持1-8M的容量，老生代则大得多
- 副垃圾回收器-Minor GC(Scavenger) 主要负责新生代的垃圾回收  
- 主垃圾回收器-Major GC 主要负责老生代的垃圾回收

**副垃圾回收器**  
通常情况下，大多数小的对象都会被分配到新生代，所以该区域虽然不大，但是垃圾回收比较频繁  
新生代中的垃圾数据用 **Scavenge算法** 来处理  
所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域(from-space)，一半是空闲区域(to-space)  
![V8堆空间](https://static001.geekbang.org/resource/image/75/9d/75329eceafd88573097f8d073430bc9d.jpg?wh=2284*1285)

新加入的对象会存放到对象区域，当对象区域快满时，就需要执行一次垃圾清理操作  
在垃圾回收过程中，首先要对对象区域中的垃圾做标记，标记完成后，就入垃圾清理阶段  

![复制对象到空闲区](https://static001.geekbang.org/resource/image/12/87/12519a0d1f2484cd24297e821f2f1887.jpg?wh=2284*1285)

副垃圾回收器会把存活的对象复制到空闲区域中，并有序排列，复制后空闲区就没有内存碎片了  
完成复制后，原对象区域变成空闲区域，原空闲区域变成对象区域。这样就完成了垃圾对象的回收操作  
这种角色翻转的操作能让新生代中这两块区域无限重复使用下去  

![新生代的对象区域和空闲区域](https://static001.geekbang.org/resource/image/79/bd/797db43b27c8a6add1ffa540910c7ebd.jpg?wh=2284*1285)

副垃圾回收器每次执行清理操作时，复制操作需要时间成本，如果新生代空间设置太大，清理时间会很长  
**因此为了执行效率，一般新生代空间会被设置的比较小**  
副垃圾回收器还会采用**对象晋升策略**，即移动那些经过两次垃圾回收依然存活的对象到老生代中  

**主垃圾回收器**  
主垃圾回收器主要负责老生代中的垃圾回收  
一些大的对象会直接被分配到老生代里
老生代对象特点
- 对象占用空间大
- 对象存活时间长

老生代对象较大，复制这些大对象非常耗时，而且会浪费一般空间，因此不适用 Scavenge算法。  
主垃圾回收器采用 **标记-清除(Mark-Sweep)** 的算法进行垃圾回收的  

标记-清除算法工作原理：  
**首先是标记过程阶段**。标记阶段时从一组根元素开始，递归遍历这组根元素，在遍历过程中，能到达的元素成为活动对象，没有到达的元素判定为垃圾数据  
**接下来时垃圾的清除过程**。主垃圾回收器会直接将标记为垃圾的数据清理掉  

![标记清除过程](https://static001.geekbang.org/resource/image/c7/9b/c70cdb85c0b656061e4cc420efdaf59b.jpg?wh=2284*1285)

对垃圾数据进行标记，然后清除，这就是**标记-清除算法**  
对一块内存多次执行标记-清除后会产生大量不连续的内存碎片，碎片过多会导致大对象无法分配到足够的连续内存，于是又引入另一算法**标记-整理(Mark-Compact)**  

这个算法标记过程与标记-清除算法一样，先标记可回收对象，但不直接对可回收对象进行整理，而是让所有存活对象都向一端移动，然后直接清理掉这一端之外的内存  
![标记整理过程](https://static001.geekbang.org/resource/image/6a/d8/6a558a6731fd68757e1a43c1dbc27ed8.jpg?wh=2284*1013)

### 垃圾回收器执行效率优化

JavaScript 运行在主线程上，一旦执行垃圾回收算法，需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做**全停顿（Stop-The-World）**

一次完整的垃圾回收分为标记和清理两个阶段，垃圾数据标记之后，V8会继续执行清理和整理操作。  
主垃圾回收器和副垃圾回收器处理方式稍有不同，但都是主线程上执行，执行过程中会暂停主线程上的其他任务，具体全停顿的执行效果如图所示  
![主线程执行效果](https://static001.geekbang.org/resource/image/90/23/9004196c53f2f381a1321bcbc346fc23.jpg?wh=2284*709)

垃圾回收时间如果过久，会阻塞主线程其他任务，造成页面卡顿等问题  

目前有两个方面来解决垃圾回收效率问题  
- 一，**将一个完成的垃圾回收任务拆分成多个小任务**，消灭单个长的垃圾回收任务
- 二，**将标记对象、移动对象等任务转移到后台线程运行**，大大减少主线程暂停的时间

并行、并发和增量

**并行回收**  
并行回收，指垃圾回收器在主线程上执行的过程中，开启多个协助线程，同时执行同样的回收工作，模式如下  
![并行回收](https://static001.geekbang.org/resource/image/00/1f/00537bdadac433a57c77c56c5cc33c1f.jpg?wh=2284*793)

**增量回收**  
并行策略能增加垃圾回收的效率，很好的优化副垃圾回收器，但仍**是一种全停顿**的垃圾回收方式  
在主线程执行回收工作的时候才会开启辅助线程，依然存在效率问题，老生代存放的都是一些大的对象，完整执行老生代的垃圾回收，时间依然会很久。因此V8 又引入了增量标记的方式  
增量式垃圾回收，指垃圾收集器将标记工作分解为更小的块，并且穿插在主线程不同的人物之间执行  
采用增量垃圾回收时，垃圾回收器没有一次执行完整的垃圾回收过程，每次只执行一小部分工作  
![增量回收](https://static001.geekbang.org/resource/image/be/6f/be18e6dc6c93e761a37d50aed48f246f.jpg?wh=2284*707)

增量标记的算法，比全停顿的算法要复杂，因为**增量回收是并发的**  
要实现增量执行，需满足两点
- 一、垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后才能继续启动  
- 二、在暂停期间，被标记好的垃圾数据如果被 JavaScript 代码修改了，那么垃圾回收器需要能够正确处理  

V8 如何实现垃圾回收器的暂停和恢复  
在采用增量算法之前，V8 使用黑色和白色来标记数据。  
执行一次完整的垃圾回收器钱，垃圾回收器将所有数据设为白色，表示这些数据还未被标记，然后垃圾回收器从 GC Roots 触发，将所有能访问到的数据标为黑色，遍历结束后，被标为黑色的数据是活动数据，白色的是垃圾数据，如图所属  
![垃圾回收器标记数据](https://static001.geekbang.org/resource/image/e1/0c/e1409de965aaab9bbf401249b1e02d0c.jpg?wh=2284*1285)

采用增量算法后，暂停了垃圾回收器，再次恢复时，垃圾回收器会不知道从哪个位置继续执行  
因此 V8 又引入了**三色标记法**，除了黑色和白色，还额外引入了灰色  
- 黑色表示这个节点被 GC Root 引用到了，而且该节点的子节点都已经标记完成了
- 灰色表示这个节点被 GC Root 引用到了，但子节点还没被垃圾回收器标记处理，也表明目前还在处理该节点
- 白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回  

引入灰色标记后，垃圾回收器可以根据当前内存中有无灰色节点来判断整个标记是否完成，若无灰色节点，则可以进行清理工作，若还有灰色标记，当下次回复垃圾回收器时，便从灰色结点开始继续执行。  

为解决暂停期间代码修改影响标记过程，增量垃圾回收器添加了一个约束条件：**不能让黑色节点指向白色节点**  
通常我们使用**写屏障（Write-barrier）机制**实现这个约束条件  
当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的，这就保证了黑色节点不能指向白色节点的约束条件，这个方法也被称为**强三色不变性**  


**并发(concurrent)回收**  
虽然通过**三色标记法和写屏障**机制可以很好的实现增量垃圾回收，但由于这些操作都在主线程上执行，若主线程繁忙，增量垃圾回收操作依然会增加主线程处理任务的**吞吐量(throughput)**  

并发回收，是指主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作。并发标记的流程如图所示  
![并发回收机制](https://static001.geekbang.org/resource/image/15/c2/157052aa087c840f5f58a7708f30bdc2.jpg?wh=2284*1213)  


并发回收的优势明显，主线程不会被挂起，JavaScript可以自由执行，执行的同时，辅助线程可以执行垃圾回收操作    
并发回收是三种回收机制中最难的，原因如下
- 第一、当主线程执行 Javascript 是，堆中的内容随时都有可能发生变化，是的辅助线程之前的工作完全无效
- 第二、 主线程和辅助线程极有可能同一时间去更改同一对象，需要额外实现读写锁的一些功能

尽管需要额外解决这两个问题，但并行回收的效率还是远高于其他方式  

这三种技术在实际使用中，通常会融合在一起使用，V8主垃圾回收器就融合了这三种机制来实现垃圾回收，具体工作流程如下图  
![主垃圾回收器的三种机制](https://static001.geekbang.org/resource/image/7b/42/7b8b901cb2eb575bb8907e1ad7dc1842.jpg?wh=2284*1105)

- 首先主垃圾回收器主要使用并发标记，在主线程执行 JavaScript，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的  
- 标记完成之后，再执行并行清理操作。主线程和多个辅助线程同时在执行清理操作
- 另外主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种 JavaScript 任务之间执行  

V8最开始的垃圾回收器有两个特点，一是垃圾回收在主线程上执行，一是一次执行一个完整的垃圾回收流程  

这两个原因容易造成主线程卡顿，因此 V8 采用了几个优化执行效率的方案  
第一个方案是并行回收，第二个方案是增量式垃圾回收，第三个方案是并发回收。  
主垃圾回收器综合采用了所有方案，副垃圾回收器也采用了部分方案  





